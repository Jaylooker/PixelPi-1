import processing.net.*;
import ddf.minim.analysis.*;
import ddf.minim.*;
import processing.serial.*;
import java.util.Random;
import java.util.Collections;

static Server s1, s2;
Client c;
String input;
String color_values;
int data[];
Integer[] nca = {0, 0, 0};
Integer[] main_rgb_to_print;
Integer[] second_rgb_to_print = {128, 128, 128};
Integer[] next_main_rgb_to_print = {255, 255, 255};
Integer[] next_second_rgb_to_print = {128, 128, 128};
Serial port;
Random rand = new Random();

Minim minim;
AudioInput in;
FFT fft;
float[] peaks;

int peak_hold_time = 1;
int[] peak_age;

int binsper_band = 5;
int peaksize;
float gain = 40;
float dB_scale = 2.0;

int buffer_size = 1024;
float sample_rate = 44100;

int spectrum_height = 176;

int[] freq_array = new int[16];
int freq_array_length = 16;
int i, g;
float f, distance_multiplier;

float[] freq_height = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int[] freq_height_lower_range = {0, 41, 181, 361, 601, 881, 1101, 1601, 2251, 3501};
int counterforspeed = 0;
int framespersecond = 60;
int randtimecounter = 0;
Integer display_mode = 0;
int display_mode_counter = 1;
int n1 = rand.nextInt(8);
int n2 = rand.nextInt(8);
float volume_adjuster = 1.0;

Rainbow rainbow = new Rainbow(1);

void setup() 
{
  main_rgb_to_print = new Integer[] {255, 255, 255};
  
  distance_multiplier = 20;
  frameRate(framespersecond);


  try {
    s1 = new Server(this, 8080);
    s2 = new Server(this, 8081);
  } 
  catch(Exception ex) {
    println("Port in use! Exiting...");
    System.exit(0);
  }

  minim = new Minim(this);
  in = minim.getLineIn(Minim.MONO, buffer_size, sample_rate);

  fft = new FFT(in.bufferSize(), in.sampleRate());
  fft.window(FFT.HAMMING);

  peaksize = 1+Math.round(fft.specSize()/binsper_band);
  peaks = new float[peaksize];
  peak_age = new int[peaksize];
}

void draw() {
  //frameRate(1);

  for (int i = 0; i < freq_array.length; i++) {
    freq_array[i] = 0;
  }

  fft.forward(in.mix);

  //for(int i = 0; i < freq_height.length; i++){
  //  distance_adjuster = 
  freq_height[0] = 2 *fft.calcAvg((float) 0, (float) 40);
  freq_height[1] = 6 *fft.calcAvg((float) 41, (float) 180);

  freq_height[2] = 9 *fft.calcAvg((float) 181, (float) 360);
  freq_height[3] = 12 *fft.calcAvg((float) 361, (float) 600);

  freq_height[4] = 14 *fft.calcAvg((float) 601, (float) 880);
  freq_height[5] = 16 *fft.calcAvg((float) 881, (float) 1200);

  freq_height[6] = 25 *fft.calcAvg((float) 1101, (float) 1600);
  freq_height[7] = 32.5 *fft.calcAvg((float) 1601, (float) 2250);

  freq_height[8] = 62.5 *fft.calcAvg((float) 2251, (float) 3500);
  freq_height[9] = 75 *fft.calcAvg((float) 3501, (float) 5000);

  freq_height[10] = 100 *fft.calcAvg((float) 5001, (float) 7000);
  freq_height[11] = 100 *fft.calcAvg((float) 7001, (float) 9000);

  freq_height[12] = 100 *fft.calcAvg((float) 9001, (float) 11000);
  freq_height[13] = 150 *fft.calcAvg((float) 11001, (float) 14000);

  freq_height[14] = 150 *fft.calcAvg((float) 14001, (float) 17000);
  freq_height[15] = 150 *fft.calcAvg((float) 17001, (float) 20000);


  for (int j=0; j<16; j++) {
    double freq_array_falue = Math.pow(freq_height[j], .5);
    freq_array[j] = freq_array_falue <= 32 ? (int)freq_array_falue : 32;
  }
  //println("2");

  String stringtosend = counterforspeed + "";
  int avg = 0;
  for (i=0; i<freq_array.length; i++) {
    avg = avg + freq_array[i];
  }

  avg = avg / freq_array.length;
  if (avg > 18) {
    volume_adjuster = volume_adjuster + 0.1;
  } else {
    if (avg < 1) {
      avg = 0;
      for (int i = 0; i < freq_array.length; i++) {
        freq_array[i] = 0;
      }
    }
    if (volume_adjuster > 1) {
      volume_adjuster = volume_adjuster - .05;
    }
  }
  
  
  

  for (i=0; i<freq_array.length; i++) {
    stringtosend = stringtosend + " " + freq_array[i];

  }
  
  stringtosend = stringtosend + " " + avg;
  
  //println(stringtosend);

  if (randtimecounter >= 30 * framespersecond) {
    n1 = rand.nextInt(8);
    n2 = rand.nextInt(8);
    randtimecounter = 0;

    switch(display_mode) {
    case 0:
      if (display_mode_counter > 6) {
        display_mode = 2;
        display_mode_counter = 0;
      } else {
        next_main_rgb_to_print = getColorValues(n1);
        next_second_rgb_to_print = getColorValues(n2);
        break;
      }

    case 2:
      if (display_mode_counter > 3) {
        display_mode = 3;
        display_mode_counter = 0;
        rainbow.clearVariables();/- 3`
      } else {
        break;
      }

    case 3:
      if (display_mode_counter >= 3) {
        display_mode = 0;
        display_mode_counter = 0;
      }
      next_main_rgb_to_print = getColorValues(n1);
      next_second_rgb_to_print = getColorValues(n2);
      break;
    }

    display_mode_counter++;
  } else {
    randtimecounter++;
  }

  if (display_mode == 0 || display_mode == 3) {
    main_rgb_to_print = calculateTransition(main_rgb_to_print, next_main_rgb_to_print);
    second_rgb_to_print = calculateTransition(second_rgb_to_print, next_second_rgb_to_print);
  } else if (display_mode == 2) {
    main_rgb_to_print = rainbow.getNextColor();
    second_rgb_to_print = rainbow.getNextColor();
  }
  color_values = getStringtoPrint(display_mode, main_rgb_to_print, second_rgb_to_print);


  
  try {
    printServer(1, stringtosend + "n");
    printServer(2, color_values + "n");
  } 
  catch(Exception e) {
    println("Write failed!");
  }

  counterforspeed++;
}


void stop() {
  // always close Minim audio classes when you finish with them
  in.close();
  minim.stop();
  s1.stop();
  s2.stop();
  super.stop();
}

String getStringtoPrint(Integer display_mode, Integer[] current_rgb, Integer[] next_rgb) {
  ArrayList<Integer> all_rgbs = new ArrayList();
  Collections.addAll(all_rgbs, current_rgb);
  Collections.addAll(all_rgbs, next_rgb);

  String color_values = display_mode.toString();
  for (i=0; i < all_rgbs.size(); i++) {
    color_values = color_values + " " + all_rgbs.get(i).toString();
  }

  return color_values;
}

//Integer[] getRandomColorValues() {
//  Integer[] new_color_values = getColorValues();

//  return new_color_values;
//}

Integer[] getColorValues(Integer newcolor) {
  Integer red, green, blue;

  if (newcolor == 0) {
    red = 255;
    green = 215;
    blue = 0;
  } else if (newcolor == 1) {
    red = 255;
    green = 0;
    blue = 0;
  } else if (newcolor == 2) {
    red = 0;
    green = 255;
    blue = 0;
  } else if (newcolor == 3) {
    red = 0;
    green = 0;
    blue = 255;
  } else if (newcolor == 4) {
    red = 255;
    green = 165;
    blue = 0;
  } else if (newcolor == 5) {
    red = 34;
    green = 139;
    blue = 34;
  } else if (newcolor == 6) {
    red = 75;
    green = 0;
    blue = 130;
  } else {
    red = 25;
    green = 25;
    blue = 112;
  }

  Integer[] color_array = {red, green, blue};

  return color_array;
}

Integer calculateIndividualTransition(Integer single_color, Integer next_color) {
  if (single_color - next_color < 5 && single_color - next_color > -5) single_color = next_color;
  else if (single_color - next_color >= 5) single_color = single_color - 5;
  else if (single_color - next_color <= -5) single_color = single_color + 5;
  return single_color;
}

Integer[] calculateTransition(Integer[] rgb, Integer[] next_rgb) {
  if (next_rgb[0] != rgb[0] || next_rgb[1] != rgb[1] || next_rgb[2] != rgb[2]) {
    for (int i = 0; i < rgb.length; i++) rgb[i] = calculateIndividualTransition(rgb[i], next_rgb[i]);
  }
  return rgb;
}

class Rainbow {
  private Integer[] rgb_array = {254, 0, 0};
  private Integer counter, decreasing_color, increasing_color, color_multiplier;

  Rainbow(int cm) {
    counter = 0;
    decreasing_color = 0;
    increasing_color = 0;
    color_multiplier = cm;
  }

  Integer[] getNextColor() {
    if (counter == 0) {
      if (increasing_color == 2) {
        increasing_color = 0;
      } else {
        increasing_color = decreasing_color + 1;
      }
    }

    counter += color_multiplier;
    rgb_array[decreasing_color] -= color_multiplier;
    rgb_array[increasing_color] += color_multiplier;

    if (counter >= 254) {
      counter = 0;
      decreasing_color += 1;
      if (decreasing_color >= 3) {
        decreasing_color = 0;
      }
    }
    return rgb_array;
  }

  void clearVariables() {
    rgb_array[0] = 254;
    rgb_array[1] = 0;
    rgb_array[2] = 0;
    counter = 0;
    decreasing_color = 0;
    increasing_color = 0;
  }
}

public static void printServer(Integer which_server, String data)throws InterruptedException {
  Integer counter = 0;
  final Integer server_to_write_to = which_server;
  final String data_to_write = data;
  Thread thread = new Thread(new Runnable() {
    @Override
      public void run() {
      //System.out.println("thread - 0");
      switch(server_to_write_to) {
      case 1:
        s1.write(data_to_write);
        break;
      case 2:
        s2.write(data_to_write);
        break;
      }
    }
  }
  );
  thread.start();
  long endTimeMillis = System.currentTimeMillis() + 250;
  while (thread.isAlive()) {
    if (System.currentTimeMillis() > endTimeMillis) {
      System.out.println("thread - 1" );
      System.exit(0);
    }
    try {
      //System.out.println("thread - 2 " + counter.toString());
      Thread.sleep(1);
    }
    catch (InterruptedException t) {
    }
    counter++;
  }
  //println("Threaddone");
}